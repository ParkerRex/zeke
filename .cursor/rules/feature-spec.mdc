---
description: Generate a comprehensive technical specification document for a new feature
---

# Feature Technical Specification Generator

You are an expert technical product manager and solutions architect tasked with creating a comprehensive Technical Product Requirements Document (PRD) for a software feature.

## When to Apply This Rule

Apply this rule when the user requests:
- Creating a technical specification for a new feature
- Generating a feature PRD (Product Requirements Document)
- Planning a new feature implementation
- Creating comprehensive technical documentation for a feature

## Process

1. **Analyze the existing project's tech stack** by examining:
   - [package.json](mdc:package.json), package-lock.json, pnpm-lock.yaml, bun.lockb, or similar dependency files
   - Existing code patterns and frameworks in use
   - Current architectural patterns and conventions

2. **Generate a 2-word kebab-case identifier** from the feature description (e.g., "user-auth", "payment-processing", "data-export")

3. **Create the directory structure**: `.agents/features/[identifier]/`

4. **Generate a comprehensive technical PRD** that aligns with the existing tech stack and save it to: `.agents/features/[identifier]/[identifier]-tech-spec.md`

## Technical PRD Structure

The document must include all of the following sections:

### Executive Summary
- Feature overview and primary purpose
- Key business value and expected impact
- High-level technical approach

### Problem Statement
- Current state and limitations
- User pain points with examples
- Business impact of not solving
- Market/competitive considerations

### Goals and Objectives
- SMART objectives (Specific, Measurable, Achievable, Relevant, Time-bound)
- Key results and success indicators
- Short-term and long-term goals

### Target Users and Use Cases
- User personas and roles
- User journey maps
- Detailed use case scenarios
- Edge cases and exception flows

### Functional Requirements
- User stories format: "As a [user], I want [functionality] so that [benefit]"
- Unique IDs (FR-001, FR-002, etc.)
- Primary flows, alternative paths, error scenarios
- Testable acceptance criteria
- Authentication, authorization, data validation, error handling

### Technical Requirements
- **Technology Stack**: Build upon existing project stack - check package.json/lock files and current codebase patterns
- **Platform Requirements**: OS, browsers, devices
- **Development Environment**: Tools, IDEs, build systems - align with existing project setup
- **Deployment Environment**: Cloud/on-premise, containers
- **Scalability**: Concurrent users, data volume, growth
- **Availability**: Uptime SLA, disaster recovery, backups
- **Compatibility**: Backward compatibility, version support

### System Architecture
- **Architecture Pattern**: Microservices, monolithic, serverless, etc.
- **Component Diagram**: System components and relationships
- **Data Flow**: How data moves through the system
- **Technology Choices**: Specific tech for each component
- **Communication Protocols**: REST, GraphQL, WebSockets, queues
- **Caching Strategy**: Cache layers, TTL, invalidation
- **State Management**: Session handling, distributed state

### Data Requirements
- **Data Models**: Entity relationships, schemas
- **Database Design**: Tables, indexes, relationships
- **Data Storage**: Primary DB, caching, file storage
- **Data Volume**: Growth, retention policies
- **Data Migration**: From existing systems if applicable
- **Data Privacy**: PII handling, encryption

### API Specifications
For each endpoint:
```
Endpoint: [METHOD] /path
Purpose: [Description]
Request:
  - Headers: [Required headers]
  - Body: [JSON schema/example]
  - Query Parameters: [Optional params]
Response:
  - Success (200): [Response schema]
  - Error Codes: [Possible errors]
Rate Limiting: [Limits]
Authentication: [Auth method]
```

### Security Requirements
- **Authentication**: OAuth, JWT, SAML, etc.
- **Authorization**: RBAC, ABAC, permissions
- **Data Encryption**: TLS, algorithms
- **Input Validation**: Sanitization, injection prevention
- **Audit Logging**: What to log, retention
- **Compliance**: GDPR, HIPAA, PCI-DSS, etc.
- **Security Testing**: Penetration testing, scanning

### Performance Requirements
- **Response Time**: P50, P95, P99 latency
- **Throughput**: Requests per second
- **Concurrent Users**: Expected and peak
- **Data Processing**: Batch times, real-time needs
- **Resource Utilization**: CPU, memory, storage limits
- **Network Requirements**: Bandwidth, latency

### Integration Requirements
- **Third-party Services**: APIs, SDKs
- **Internal Systems**: Dependencies
- **Data Exchange**: JSON, XML, Protocol Buffers
- **Integration Patterns**: Sync/async, webhooks
- **Error Handling**: Retry logic, circuit breakers
- **Version Management**: API versioning

### Testing Strategy
- **Unit Testing**: Coverage, frameworks
- **Integration Testing**: API, contract testing
- **Performance Testing**: Load testing
- **Security Testing**: Vulnerability scanning
- **User Acceptance**: Test scenarios
- **Regression Testing**: Automated suites

### Success Metrics and KPIs
- **Business Metrics**: Revenue, cost savings, efficiency
- **Technical Metrics**: Performance, error rates, uptime
- **User Metrics**: Adoption, satisfaction, completion
- **Quality Metrics**: Defect density, coverage, tech debt

### Risk Assessment
- **Technical Risks**: Technology, complexity, performance
- **Integration Risks**: Third-party dependencies
- **Security Risks**: Vulnerabilities, breaches
- **Business Risks**: Market changes, resources
- **Mitigation Strategies**: Specific actions
- **Contingency Plans**: Fallback approaches

### Dependencies and Constraints
- **External Dependencies**: Third-party services, APIs
- **Internal Dependencies**: Teams, systems, projects
- **Technical Constraints**: Platform limitations
- **Business Constraints**: Budget
- **Assumptions**: Key design assumptions

## Critical Guidelines

- **ALWAYS examine the existing project's package.json, lock files, and codebase first**
- **Recommend technologies that are already in use in the project when possible**
- **Only suggest new dependencies if absolutely necessary for the feature**
- **Follow existing architectural patterns and conventions found in the codebase**

## Output Requirements

Create a complete technical PRD that:
- Aligns with the existing project's technology choices and patterns
- Provides enough detail for architects to create implementation plans
- Gives developers clear specifications to build against
- Enables QA teams to create comprehensive test plans
- Allows DevOps to plan infrastructure and deployment
- Helps security teams assess and address risks

Save the completed specification to `.agents/features/[identifier]/[identifier]-tech-spec.md`

After saving, output: "âœ… Created tech spec: `.agents/features/[identifier]/[identifier]-tech-spec.md`"

Then provide the command for the next step:
"ðŸ“‹ To create an implementation plan, run: `/feature-plan .agents/features/[identifier]/[identifier]-tech-spec.md`"