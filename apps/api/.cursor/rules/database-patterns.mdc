---
description: "How the database layer works (Drizzle + replicas) and how to use it in REST/TRPC."
globs:
  - "apps/api/src/**/*"
  - "packages/db/src/**/*"
alwaysApply: true
---

### Database patterns (Drizzle + replicas)

- **Single client**: Import the database from `@midday/db/client` as `db`. Do not create new pools.
  - Primary pool is at `DATABASE_PRIMARY_URL`.
  - Read replicas: `DATABASE_FRA_URL`, `DATABASE_IAD_URL`, `DATABASE_SJC_URL`.
  - `FLY_REGION` selects the nearest replica for reads; writes always go to primary.
  - Drizzle is configured with `casing: "snake_case"`; table/column names map accordingly.

- **Replica routing**: The `withReplicas` wrapper sends:
  - Reads (`select`, `$count`, `query`, etc.) to the chosen replica.
  - Writes (`insert`, `update`, `delete`, `execute`, `transaction`) to primary.
  - `usePrimaryOnly()` forces subsequent reads to primary on the same handle.
  - `executeOnReplica()` exists for explicit replica reads when needed.

- **Read-after-write consistency**: Use the provided middleware; do not hand-roll.
  - REST: `withPrimaryReadAfterWrite` (Hono) auto-switches to primary after a mutation and for a short window for that team.
  - TRPC: a parallel `withPrimaryReadAfterWrite` enforces the same on `mutation` and recent `query` calls.
  - Internally uses `replicationCache` keyed by team to decide when to pin reads to primary.

- **Context contract (REST)**:
  - `withDatabase` sets `db` on the request context.
  - `withAuth` sets `session` and scopes.
  - `withPrimaryReadAfterWrite` may replace `db` with `db.usePrimaryOnly()` and sets `teamId`.
  - Always read from context: `const db = c.get("db"); const teamId = c.get("teamId");` and pass `teamId` to all query fns.

- **Context contract (TRPC)**:
  - `createTRPCContext` provides `db`, `session`, and an optional `teamId`.
  - Routers should rely on query functions from `@midday/db/queries` and include `teamId`.
  - The TRPC `withPrimaryReadAfterWrite` middleware handles primary pinning for mutations and recent queries.

- **Team scoping**:
  - Most query functions in `@midday/db/queries/*` require a `teamId`. Always pass it.
  - For OAuth tokens, `teamId` comes from the token. Otherwise it is derived via `getUserTeamId` and cached in `teamPermissionsCache`.

- **Caches around DB**:
  - `apiKeyCache`, `userCache` (auth), `teamPermissionsCache` (team), and `replicationCache` (consistency) reduce DB load. Use the middlewares; do not bypass.

- **Operational health**:
  - `/health` is a lightweight probe; `/health/db` runs a quick query and includes pool summary; `/health/pools` exposes live pool stats via `getConnectionPoolStats()`.

- **Module boundaries**:
  - Use `@midday/db/queries` for all data access. Prefer these helpers over ad-hoc SQL.
  - Drizzle types `Database` come from `@midday/db/client`. Do not confuse with Supabase types in `packages/supabase/src/types/db.ts`.
  - Path aliasing: `@db/*` â†’ `packages/db/src/*` (see `apps/api/tsconfig.json`).

### Do / Don't

- Do: `const db = c.get("db"); await getTransactions(db, { teamId, ... })`.
- Do: Pass `teamId` and `userId` (for writes) to query functions where applicable.
- Do: Let the provided middlewares handle auth, team resolution, caching, and read-after-write.
- Don't: Instantiate your own `Pool` or call raw `drizzle(...)` in API code.
- Don't: Bypass `withPrimaryReadAfterWrite` or read from replicas immediately after a write.
- Don't: Import Supabase `Database` type where Drizzle `Database` is expected.

### Environment reference

- Required: `DATABASE_PRIMARY_URL`
- Replicas (recommended in production): `DATABASE_FRA_URL`, `DATABASE_IAD_URL`, `DATABASE_SJC_URL`
- Region hint: `FLY_REGION` (used to pick the closest replica for reads)

### Quick example (REST handler skeleton)

```ts
// inside a route handler
const db = c.get("db");
const teamId = c.get("teamId");
const data = await getInvoices(db, { teamId, pageSize: 50 });
return c.json({ data });
```

