---
description: "REST API patterns for Hono + Zod OpenAPI in apps/api"
globs:
  - apps/api/src/rest/**/*.ts
  - apps/api/src/schemas/**/*.ts
  - apps/api/src/index.ts
  - apps/api/src/rest/middleware/**/*.ts
alwaysApply: true
---

### Overview

- The REST API is built with Hono and zod-openapi.
- Each resource has a router under `apps/api/src/rest/routers/*` using `OpenAPIHono<Context>()` and `createRoute` for OpenAPI metadata.
- Input validation is defined in `apps/api/src/schemas/*` and enforced via `c.req.valid('query'|'json'|'param')`.
- Responses MUST be validated with `validateResponse(data, schema)` before returning.
- Authentication and context (database/session/team) are provided by middleware.

### App bootstrap and docs

- `apps/api/src/index.ts` wires global middleware, TRPC, health checks, and OpenAPI docs. Scalar UI is served at `/` and OpenAPI JSON at `/openapi`.
- Global CORS is controlled by `ALLOWED_API_ORIGINS` and default headers/methods.

### Router registration and protection

- `apps/api/src/rest/routers/index.ts` mounts routers.
  - Public routes (e.g., OAuth) must be mounted BEFORE `protectedMiddleware`.
  - All subsequent routes inherit `protectedMiddleware`:
    - `withDatabase` → sets `db`
    - `withAuth` → validates Bearer token (OAuth or API key), sets `session`, `teamId`, `scopes`
    - user-scoped `rateLimiter`
    - `withPrimaryReadAfterWrite` → routes queries to primary when needed

### Auth model

- Authorization: `Authorization: Bearer <token>`
  - OAuth access tokens start with `mid_access_token_` and are validated server-side.
  - API keys start with `mid_` and are hashed/verified; both yield `session`, `teamId`, and expanded `scopes`.
- Scopes: Gate each route with `withRequiredScope('<resource>.<permission>')`. Prefer `read`/`write` verbs.

### Context contract (use consistently)

- Handlers read context via Hono’s per-request store:
  - `const db = c.get('db')` (Drizzle Database or primary-only wrapper)
  - `const teamId = c.get('teamId')` (string)
  - `const session = c.get('session')` (user id/email, optional oauth app info)
  - `const scopes = c.get('scopes')` (if needed)

### Route definition pattern

- Use `OpenAPIHono<Context>()` and `app.openapi(createRoute({...}), handler)`.
- Always provide: `method`, `path`, `summary`, `operationId`, `description`, `tags`, `request` (params/query/body schemas as applicable), `responses` (status → schema), and `middleware` (scopes).
- Prefer `operationId` verbs: list/get/create/update/delete; include `x-speakeasy-name-override` for SDK naming.

```ts
// Skeleton for a new resource router
import type { Context } from "@api/rest/types";
import { OpenAPIHono, createRoute } from "@hono/zod-openapi";
import { withRequiredScope } from "../middleware";
import { getFoosSchema, fooResponseSchema, foosResponseSchema, upsertFooSchema, getFooByIdSchema, deleteFooSchema } from "@api/schemas/foos";
import { getFoos, getFooById, upsertFoo, deleteFoo } from "@midday/db/queries";
import { validateResponse } from "@api/utils/validate-response";

const app = new OpenAPIHono<Context>();

app.openapi(
  createRoute({
    method: "get",
    path: "/",
    summary: "List foos",
    operationId: "listFoos",
    "x-speakeasy-name-override": "list",
    tags: ["Foos"],
    request: { query: getFoosSchema },
    responses: { 200: { content: { "application/json": { schema: foosResponseSchema } }, description: "List" } },
    middleware: [withRequiredScope("foos.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const query = c.req.valid("query");
    const result = await getFoos(db, { teamId, ...query });
    return c.json(validateResponse(result, foosResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    summary: "Get foo",
    operationId: "getFooById",
    "x-speakeasy-name-override": "get",
    tags: ["Foos"],
    request: { params: getFooByIdSchema },
    responses: { 200: { content: { "application/json": { schema: fooResponseSchema } }, description: "Details" } },
    middleware: [withRequiredScope("foos.read")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;
    const result = await getFooById(db, { id, teamId });
    return c.json(validateResponse(result, fooResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "post",
    path: "/",
    summary: "Create foo",
    operationId: "createFoo",
    "x-speakeasy-name-override": "create",
    tags: ["Foos"],
    request: { body: { content: { "application/json": { schema: upsertFooSchema } } } },
    responses: { 201: { content: { "application/json": { schema: fooResponseSchema } }, description: "Created" } },
    middleware: [withRequiredScope("foos.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const session = c.get("session");
    const body = c.req.valid("json");
    const result = await upsertFoo(db, { teamId, userId: session.user.id, ...body });
    return c.json(validateResponse(result, fooResponseSchema), 201);
  },
);

app.openapi(
  createRoute({
    method: "patch",
    path: "/{id}",
    summary: "Update foo",
    operationId: "updateFoo",
    "x-speakeasy-name-override": "update",
    tags: ["Foos"],
    request: { params: getFooByIdSchema, body: { content: { "application/json": { schema: upsertFooSchema.omit({ id: true }) } } } },
    responses: { 200: { content: { "application/json": { schema: fooResponseSchema } }, description: "Updated" } },
    middleware: [withRequiredScope("foos.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;
    const body = c.req.valid("json");
    const result = await upsertFoo(db, { id, teamId, ...body });
    return c.json(validateResponse(result, fooResponseSchema));
  },
);

app.openapi(
  createRoute({
    method: "delete",
    path: "/{id}",
    summary: "Delete foo",
    operationId: "deleteFoo",
    "x-speakeasy-name-override": "delete",
    tags: ["Foos"],
    request: { params: deleteFooSchema },
    responses: { 200: { content: { "application/json": { schema: fooResponseSchema } }, description: "Deleted" } },
    middleware: [withRequiredScope("foos.write")],
  }),
  async (c) => {
    const db = c.get("db");
    const teamId = c.get("teamId");
    const id = c.req.valid("param").id;
    const result = await deleteFoo(db, { id, teamId });
    return c.json(validateResponse(result, fooResponseSchema));
  },
);

export const foosRouter = app;
```

### Validation and response guarantees

- Import schemas from `@api/schemas/*`.
- Read inputs exclusively via `c.req.valid('query'|'json'|'param')` to ensure they match the schema.
- Before returning, wrap the payload with `validateResponse(result, <ResponseSchema>)`.
- Use `HTTPException(status, { message })` for error paths; otherwise return `c.json(payload, status?)`.

### Pagination and sorting

- Query schemas commonly include `cursor?: string | null` and `pageSize?: number`.
- Sorting is `[field, direction]` (e.g., `["createdAt","desc"]`).
- List responses include a `meta` object:
  - `cursor: string | null`
  - `hasPreviousPage: boolean`
  - `hasNextPage: boolean`

### Primary read-after-write routing

- Included in `protectedMiddleware`. Mutations always hit primary. For subsequent reads by the same team, primary is used for a brief window to avoid replica lag.
- Handlers continue to use `c.get('db')`; the middleware swaps in the primary-only connection when needed.

### Pre-signed URL endpoints (pattern)

- Method: `POST /{id}/presigned-url` (or nested resource path).
- Steps:
  1) Load the entity by `id` + `teamId` and verify existence and team ownership.
  2) Ensure a file path exists (array of path tokens).
  3) Create admin Supabase client via `createAdminClient()`.
  4) Generate URL with `signedUrl(supabase, { bucket: "vault", path, expireIn: 60, options: { download }})`.
  5) Return `{ url, expiresAt, fileName }` validated against the appropriate response schema.

### Transformation rules (when applicable)

- It’s acceptable to transform DB records for REST (e.g., compute invoice totals, serialize rich JSON fields to strings) as long as the response schema matches the transformed shape.
- Keep such logic local to the router; persist only domain changes via queries.

### OpenAPI hygiene

- Always provide descriptive `summary`/`description`/`tags`.
- Use `operationId` consistently. Add `x-speakeasy-name-override` to influence SDK method names (e.g., `list`, `get`, `create`, `update`, `delete`).
- Ensure params (`{id}`), query, and body match the schemas’ OpenAPI metadata (e.g., `param: { in: 'path', name: 'id' }`).

### Error handling & rate limits

- Throw `HTTPException(401|403|404|409|429|500, { message })` as needed; let Hono convert to proper responses.
- Per-user rate limiting (~10 min window, 100 requests) is applied in `protectedMiddleware`.
- Public routes (e.g., OAuth) apply IP-based rate limiting.

### CORS and headers

- CORS is configured globally. If adding new custom headers, update `allowHeaders` in `src/index.ts`.

### Team scoping

- All protected routes MUST derive `teamId` from auth middleware and never from arbitrary request input.
- Data access must include `teamId` filters.

### Deployment/runtime notes (FYI)

- Bun runtime; server listens on `process.env.PORT` (Fly’s internal port is 8080).
- Dockerfile runs `bun run src/index.ts` in production; Fly configs control scaling and health checks.

### Quick checklist for new routes

- [ ] Define request/response schemas in `@api/schemas/<resource>.ts`.
- [ ] Create an `OpenAPIHono<Context>()` router.
- [ ] For each endpoint, use `createRoute` with full OpenAPI metadata and `withRequiredScope`.
- [ ] Use `c.get('db'|'teamId'|'session')`, not ad-hoc parsing.
- [ ] Read inputs via `c.req.valid(...)`.
- [ ] Validate outputs with `validateResponse(...)`.
- [ ] Return proper HTTP codes (201 for create, 200 otherwise; 204 only when returning no body).
- [ ] Register the router in `routers/index.ts` under the protected section (unless intentionally public).
