---
description: TRPC patterns used in Midday API — context, middleware, auth, DB usage, naming, schemas, and how to add routers/procedures.
globs:
  - apps/api/src/trpc/**/*.ts
  - apps/api/src/index.ts
alwaysApply: true
---

### Overview
- Runtime: Bun. HTTP server: Hono. TRPC is mounted at `/trpc/*` via `@hono/trpc-server`.
- Transformer: superjson. Imports use path aliases (`@api/*`, `@midday/*`).
- DB: shared Drizzle client from `@midday/db/client` (read replicas + `usePrimaryOnly()`).
- Auth: TRPC uses Supabase access tokens (Bearer). REST uses API keys/OAuth.

### Context
- Built in `createTRPCContext` and passed to all procedures:
  - `session`: Supabase-verified user or `null`
  - `supabase`: client bound to the incoming access token
  - `db`: Drizzle `Database`
  - `geo`: derived from the request
  - `teamId?`: injected by middleware when applicable

Access it by destructuring from `ctx`:
```ts
.query(async ({ ctx: { db, teamId, session }, input }) => { ... })
```

### Middleware chain
- `withTeamPermission` (protected only)
  - Verifies a signed-in user
  - Resolves the user’s current `teamId` and checks membership (cached)
  - Injects `teamId` onto `ctx` (can be `null`, which is allowed)
- `withPrimaryReadAfterWrite` (public + protected)
  - Mutations: switch `db` to primary and mark team as recently-mutated
  - Queries: if team recently mutated, use primary; otherwise use replica
  - If `teamId` is missing, default to primary to be safe

You do not need to manually pick primary vs replica; the middleware handles it.

### Procedure types
- `publicProcedure`: no auth requirement. Still benefits from primary read-after-write logic.
- `protectedProcedure`: requires a valid `session`. Also runs team permission checks and adds `teamId` to `ctx`.

Use:
```ts
export const invoiceRouter = createTRPCRouter({
  get: protectedProcedure
    .input(getInvoicesSchema.optional())
    .query(async ({ ctx: { db, teamId }, input }) => {
      return getInvoices(db, { teamId: teamId!, ...input });
    }),
  getInvoiceByToken: publicProcedure
    .input(getInvoiceByTokenSchema)
    .query(async ({ ctx: { db }, input }) => { ... }),
  update: protectedProcedure
    .input(updateInvoiceSchema)
    .mutation(async ({ ctx: { db, teamId, session }, input }) => {
      return updateInvoice(db, { ...input, teamId: teamId!, userId: session.user.id });
    }),
});
```

### Inputs and schemas
- Always use zod schemas from `apps/api/src/schemas/*`.
- `.input(schema)` on procedures; do not parse raw request bodies manually.
- Superjson allows rich values in responses (Dates, Maps, etc.).

### Error handling
- Throw `new TRPCError({ code, message })`. Prefer semantic codes: `UNAUTHORIZED`, `FORBIDDEN`, `NOT_FOUND`, `BAD_REQUEST`, etc.
- Do not return error-shaped objects; throw instead.

### DB usage
- Always use `ctx.db`; never import a fresh client per request.
- Pass `teamId: teamId!` to query helpers from `@midday/db/queries` when team scoping is required.
- Mutations are automatically routed to primary; follow-up queries will read primary within the replication window.

### Auth model (TRPC vs REST)
- TRPC: Bearer Supabase access tokens only (first‑party, user-centric).
- REST: API keys and OAuth access tokens (third‑party/app integrations). Do not reuse REST auth in TRPC.

### Background jobs and side effects
- Use `@trigger.dev/sdk` (`tasks.trigger`, `runs.reschedule`, `runs.cancel`) inside mutations for async work (e.g., invoice generation, scheduling).
- Side effects must occur after the DB write succeeds; prefer idempotent jobs.
- Queries must be side‑effect free.

### Router organization
- One file per domain under `apps/api/src/trpc/routers/*`.
- Export a router via `createTRPCRouter({...})`.
- Wire it in `apps/api/src/trpc/routers/_app.ts` under a descriptive key.
- Export `AppRouter`, `RouterInputs`, `RouterOutputs` from `_app.ts` for client inference.

### Naming conventions
- Use clear verb-based names: `get`, `getById`, `create`, `update`, `delete`, `search`, `summary`, etc.
- For domain-specific flows, prefer explicit names (e.g., `createFromTracker`, `updateSchedule`).
- Keep queries read-only; use mutations for writes.

### Adding a new TRPC router (checklist)
1. Create `apps/api/src/trpc/routers/<domain>.ts`.
2. Import `createTRPCRouter`, `publicProcedure`/`protectedProcedure`.
3. Import zod schemas from `@api/schemas/<domain>`.
4. Implement queries/mutations using `ctx.db`, `ctx.teamId`, `ctx.session`.
5. Throw `TRPCError` for failures; don’t return error literals.
6. Add your router to `apps/api/src/trpc/routers/_app.ts`.
7. If you need jobs, trigger them after successful DB writes.

### Mounting
- TRPC is mounted in `apps/api/src/index.ts` at `/trpc/*` with `createTRPCContext` and `appRouter`.
- CORS/headers are handled at the Hono app level; TRPC inherits those settings.

### When to choose TRPC vs REST
- Use TRPC for first-party app traffic (dashboard/desktop), Supabase auth, and tight type-safety end‑to‑end.
- Use REST for third-party integrations, API keys, OAuth flows, and public documentation via OpenAPI.
