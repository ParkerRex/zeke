---
description: Midday Dashboard architecture and extension guidelines for Next.js App Router + tRPC + Supabase + TanStack Query
globs:
  - apps/dashboard/**
alwaysApply: true
---

## Midday Dashboard Architecture (Next.js App Router + tRPC + Supabase)

- UI: Next.js App Router with route groups and per-locale routing under `src/app/[locale]/*`.
- Data: tRPC calls to the API (`NEXT_PUBLIC_API_URL`), integrated with TanStack Query and SuperJSON.
- Auth: Supabase session (cookies) enforced in `src/middleware.ts` with redirects and MFA checks.
- i18n: `next-international` (server + client) with locale rewrite middleware.
- State: Small, focused Zustand stores in `src/store/*` for ephemeral UI state.
- Desktop: Conditional UI/behavior via `DesktopHeader`/`DesktopProvider` and `isDesktopApp()`.

### Directory layout (Dashboard)
- `src/app/[locale]/layout.tsx`: Global HTML shell, fonts, `NuqsAdapter`, Toaster, Analytics, and `Providers`.
- `src/app/[locale]/(app)/(sidebar)/layout.tsx`: Auth-gated app shell (Sidebar + Header) and SSR data prefetch.
- `src/app/[locale]/(public)/*`: Public pages (login, verify, etc.).
- `src/trpc/*`: tRPC client/provider (client) and SSR helpers (server) with React Query integration.
- `src/actions/*`: Server actions. Prefer `next-safe-action` via `authActionClient` when user/auth/analytics are involved.
- `src/store/*`: Small Zustand stores (e.g., search/export modal state).
- `src/locales/*`: `next-international` config and dictionaries.
- `src/hooks/*`: URL/search param helpers and domain-centric hooks.

---

## Routing, layouts, and SSR data flow

### Auth-gated app shell
- The `(app)/(sidebar)` layout performs prefetch and gating:
  - Prefetches common queries with `batchPrefetch([...trpc.<domain>.<query>.queryOptions()])`.
  - Ensures `user` is loaded; redirects to `/login`, `/setup`, or `/teams` when required.
  - Wraps children in `<HydrateClient>` to hydrate prefetched data.

### Server-side prefetch pattern (use in layouts/pages)
1) Import helpers from `src/trpc/server`.
2) Use `batchPrefetch` for broad preloading and `queryClient.fetchQuery` for above-the-fold data.
3) Return JSX wrapped with `<HydrateClient>`.

Checklist:
- Prefer server prefetch for content visible at first paint.
- Push non-critical queries to the client (suspense/after mount) or use `batchPrefetch` only.
- Keep redirects in layouts (not client components).

---

## tRPC + TanStack Query usage

### Client-side
- Wrap the app with `TRPCReactProvider` (in `Providers`).
- Get typed options via `const trpc = useTRPC()`.
- Use TanStack `useQuery`/`useMutation` with trpc-generated `queryOptions`/`mutationOptions`:

```tsx
"use client";
import { useTRPC } from "@/trpc/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";

export function Example() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  const { data } = useQuery(trpc.things.get.queryOptions({ pageSize: 10 }));

  const createThing = useMutation(
    trpc.things.create.mutationOptions({
      onSuccess: () => {
        queryClient.invalidateQueries({
          queryKey: trpc.things.get.queryKey(),
        });
      },
    }),
  );

  return <button onClick={() => createThing.mutate({ name: "New" })}>Add</button>;
}
```

Notes:
- Invalidate using `queryKey: trpc.<domain>.<query>.queryKey()`.
- QueryClient defaults: `staleTime = 60s`; SuperJSON is used for (de)serialization.

### Server-side
- `src/trpc/server.tsx` exposes:
  - `trpc`: builder for `.queryOptions()`/`.mutationOptions()`.
  - `getQueryClient()`: request-scoped QueryClient.
  - `HydrateClient`: wraps children with `HydrationBoundary`.
  - `batchPrefetch()` and `prefetch()` utilities.
- The http link attaches headers:
  - `Authorization: Bearer <Supabase access token>`
  - `x-user-timezone`, `x-user-locale`, `x-user-country`

---

## Middleware, auth, and access control

`src/middleware.ts` combines i18n rewriting with Supabase session enforcement:
- Locale handling via `createI18nMiddleware({ locales: ["en"], defaultLocale: "en", urlMappingStrategy: "rewrite" })`.
- Not authenticated → redirect to `/login` (preserves a `return_to` back to the original path).
- Allows invite routes (`/teams/invite/...`) without blocking setup.
- MFA enforcement: if `aal2` required and not satisfied, redirect to `/mfa/verify`.
- Matcher excludes `_next/*`, images, and `/api`.

Guidelines:
- Keep auth gating in layouts and middleware, not client components.
- When adding new public routes, ensure they’re allowed by middleware checks.

---

## Server actions

There are two patterns:

1) Safe, typed actions with analytics and auth context (preferred for user-triggered flows):

```ts
"use server";
import { z } from "zod";
import { authActionClient } from "@/actions/safe-action";

export const doSomethingAction = authActionClient
  .schema(z.object({ id: z.string() }))
  .metadata({ name: "do-something" })
  .action(async ({ parsedInput: { id }, ctx: { user, analytics } }) => {
    // Perform side effects, track, and return data
    analytics.track({ event: "do_something" });
    return { id };
  });
```

2) Lightweight server functions for engine/API calls without extra metadata:

```ts
"use server";
import { client } from "@midday/engine-client";
import { getSession } from "@midday/supabase/cached-queries";

export const createLinkToken = async () => {
  const { data: { session } } = await getSession();
  const res = await client.auth.plaid.link.$post({ json: { userId: session?.user?.id } });
  if (!res.ok) throw new Error("Failed to create link token");
  const { data } = await res.json();
  return data.link_token;
};
```

Guidelines:
- Prefer `authActionClient` when you need: auth context, analytics, input validation with Zod, and consistent error handling.
- Name files with `*-action.ts` for safe actions; export the action with an explicit verb.
- Logically group actions under `src/actions/<domain>`.

---

## State management (Zustand)

- Keep stores minimal and domain-specific under `src/store/*`.
- Store only ephemeral UI state (modals, toggles). Persisted data should come from tRPC/React Query.

Example:
```ts
import { create } from "zustand";

type SearchState = { isOpen: boolean; setOpen: () => void };
export const useSearchStore = create<SearchState>()((set) => ({
  isOpen: false,
  setOpen: () => set((s) => ({ isOpen: !s.isOpen })),
}));
```

---

## i18n (next-international)

- Server helpers: `src/locales/server.ts` exports `getI18n`, `getScopedI18n`, `getStaticParams`.
- Client hooks/provider: `src/locales/client.ts` exports `I18nProviderClient`, `useI18n`, etc.
- Global provider: mounted in `src/app/[locale]/providers.tsx`.
- To add a new locale:
  1) Add dictionary import in `locales/server.ts` and `locales/client.ts`.
  2) Add the locale to `languages` (client) and `createI18nMiddleware({ locales: [...] })`.
  3) Provide translations in `locales/<code>.ts`.

---

## Providers and globals

- `Providers` wraps: `TRPCReactProvider` → `I18nProviderClient` → `DesktopProvider` → `ThemeProvider`.
- Top-level layout applies fonts, desktop class, and analytics provider.
- Use `NuqsAdapter` to bind URL query state.

---

## Adding a new page or feature (checklist)

1) Page under `(app)/(sidebar)`
- Create `src/app/[locale]/(app)/(sidebar)/<page>/page.tsx`.
- Server prefetch with `batchPrefetch` and `queryClient.fetchQuery` for above-the-fold data.
- Wrap output with `<HydrateClient>`.

2) Client component data fetching
- Use `useTRPC()` to get options and TanStack `useQuery`/`useMutation`.
- Invalidate on mutation success using `trpc.<domain>.<query>.queryKey()`.

3) Server action
- Prefer `authActionClient` for user-initiated writes and analytics.
- Validate input with Zod; return typed data.

4) i18n
- Wrap client components with `I18nProviderClient` via `Providers`.
- Use `useI18n()`/`useScopedI18n()` for strings.

5) Middleware
- If adding public routes, ensure middleware allows them.

---

## Gotchas

- Always render inside `TRPCReactProvider` and hydrate with `HydrateClient` when server-prefetching.
- Do not call tRPC directly in server components without using `.queryOptions()` + QueryClient; stick to the provided helpers.
- Keep redirects server-side (layouts/pages) to avoid client flashes.
- Remember to include `Authorization` in server tRPC headers; the helpers do this for you.
- When adding a new locale, update both client/server locale registries and middleware.

---

## Key files to know
- `src/app/[locale]/layout.tsx` – global shell, Providers, Nuqs, Analytics, Toaster.
- `src/app/[locale]/(app)/(sidebar)/layout.tsx` – SSR prefetch, gating, app chrome.
- `src/trpc/server.tsx` – SSR helpers, query client, prefetch, hydration.
- `src/trpc/client.tsx` – TRPC React provider and client links.
- `src/actions/safe-action.ts` – safe action clients (auth, analytics, error handling).
- `src/middleware.ts` – auth + i18n middleware and redirects.
- `src/locales/*` – server/client i18n setup and dictionaries.
- `src/store/*` – Zustand UI stores.
