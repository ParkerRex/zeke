---
description: "Midday Desktop (Tauri v2) architecture, window/events patterns, environments, deep links, updater, and how to extend it"
globs:
  - apps/desktop/**
  - packages/desktop-client/**
alwaysApply: true
---

### Overview

- **What it is**: A thin Tauri v2 shell that hosts the Midday web app with native desktop affordances (global shortcut search, deep links, updater, system tray, external URL handling).
- **How it renders**: The main window loads an external URL based on `MIDDAY_ENV` (development, staging, production). The React `src/` bundle is not the primary UI; the shell points at the web app.
- **Key behaviors**: Global shortcut `Shift+Alt+K` toggles a lightweight search window, deep links trigger in-app navigation, external links open in the system browser, updater is user‚Äëdriven via tray.

### Entrypoints and layout

- `apps/desktop/src-tauri/src/main.rs`: Rust entrypoint; delegates to `midday_lib::run()`.
- `apps/desktop/src-tauri/src/lib.rs`: Core shell ‚Äì creates windows, registers plugins/commands, wires events, tray, and shortcuts.
- `apps/desktop/tauri.conf.json` (+ `tauri.dev.conf.json`, `tauri.staging.conf.json`): Bundle/plugins configuration and per‚Äëenv overrides.
- `apps/desktop/package.json`: Dev/build scripts that set `MIDDAY_ENV` for local runs and builds.

#### Environment selection (URL routing)
The shell selects which web app to load via `MIDDAY_ENV`:

```312:346:apps/desktop/src-tauri/src/lib.rs
fn get_app_url() -> String {
    // Try runtime environment variable first, then fall back to compile-time
    let env = env::var("MIDDAY_ENV")
        .unwrap_or_else(|_| {
            option_env!("MIDDAY_ENV")
                .unwrap_or("development")
                .to_string()
        });

    println!("üåç Environment detected: {}", env);

    match env.as_str() {
        "development" | "dev" => {
            let url = "http://localhost:3001".to_string();
            println!("üåç Using development URL: {}", url);
            url
        },
        "staging" => {
            let url = "https://beta.midday.ai".to_string();
            println!("üåç Using staging URL: {}", url);
            url
        },
        "production" | "prod" => {
            let url = "https://app.midday.ai".to_string();
            println!("üåç Using production URL: {}", url);
            url
        },
        _ => {
            eprintln!("Unknown environment: {}, defaulting to development", env);
            let url = "http://localhost:3001".to_string();
            println!("üåç Using fallback development URL: {}", url);
            url
        }
    }
}
```

Local scripts that set `MIDDAY_ENV` for dev/builds:

```10:16:apps/desktop/package.json
    "tauri": "tauri",
    "tauri:dev": "MIDDAY_ENV=development tauri dev --config src-tauri/tauri.dev.conf.json",
    "tauri:staging": "MIDDAY_ENV=staging tauri dev --config src-tauri/tauri.staging.conf.json",
    "tauri:prod": "MIDDAY_ENV=production tauri dev",
    "tauri:build:dev": "tauri build --config src-tauri/tauri.dev.conf.json",
    "tauri:build:staging": "tauri build --config src-tauri/tauri.staging.conf.json",
    "tauri:build:prod": "tauri build"
```

### Window model

- **Main window**: Loads the app URL, transparent titlebar, fixed min size, external links intercepted.
- **Search window**: On‚Äëdemand secondary window (hidden by default), small, always‚Äëon‚Äëtop when shown, auto‚Äëhides on blur, centered on current monitor.

Create the main window and intercept external navigation:

```465:507:apps/desktop/src-tauri/src/lib.rs
            let win_builder = WebviewWindowBuilder::new(
                app,
                "main",
                WebviewUrl::External(tauri::Url::parse(&app_url).unwrap()),
            )
            .title("Midday")
            .inner_size(1450.0, 900.0)
            .min_inner_size(1450.0, 900.0)
            .user_agent("Mozilla/5.0 (compatible; Midday Desktop App)")
            .decorations(false)
            .visible(false)
            .transparent(true)
            .shadow(true)
            .hidden_title(true)
            .title_bar_style(TitleBarStyle::Overlay)
            .disable_drag_drop_handler()
            .on_download(|_window, _event| {
                println!("Download triggered!");
                // Allow all downloads - they will go to default Downloads folder
                true
            })
            .on_navigation(move |url| {
                let url_str = url.as_str();

                // Check if this is an external URL
                if is_external_url(url_str, &app_url_clone) {
                    // Clone the URL string to avoid lifetime issues
                    let url_string = url_str.to_string();
                    let app_handle_clone = app_handle_for_navigation.clone();

                    // Open in system browser using the opener plugin
                    tauri::async_runtime::spawn(async move {
                        let _ = tauri_plugin_opener::OpenerExt::opener(&app_handle_clone)
                                .open_url(url_string, None::<String>);
                    });

                    // Prevent navigation in webview
                    return false;
                }

                // Allow internal navigation
                true
            });
```

Search window creation (hidden, overlay, small, always‚Äëon‚Äëtop when shown):

```253:276:apps/desktop/src-tauri/src/lib.rs
    let mut search_builder = WebviewWindowBuilder::new(
        app,
        search_window_label,
        WebviewUrl::External(tauri::Url::parse(&search_url)?),
    )
    .title("Midday Search")
    .inner_size(720.0, 450.0)
    .min_inner_size(720.0, 450.0)
    .resizable(false)
    .user_agent("Mozilla/5.0 (compatible; Midday Desktop App)")
    .transparent(true)
    .decorations(false)
    .visible(false) // Start hidden for preloading
    .on_download(|_window, _event| {
        println!("Search window download triggered!");
        // Allow downloads from search window too
        true
    });

    // Platform-specific styling
    search_builder = search_builder
        .hidden_title(true)
        .title_bar_style(TitleBarStyle::Overlay);
```

Toggle logic (global shortcut and tray use the same function):

```141:160:apps/desktop/src-tauri/src/lib.rs
    if let Some(window) = app.get_webview_window(search_window_label) {
        println!("üîç Found existing search window");
        if window.is_visible()? {
            println!("üîç Search window is visible, hiding it");
            // Emit close event to search window
            let _ = window.emit("search-window-open", false);
            window.hide()?;
        } else {
            println!("üîç Search window is hidden, showing it");
            // Set always on top when showing
            window.set_always_on_top(true)?;
            position_window_on_current_monitor(app, &window)?;
            window.show()?;
            window.set_focus()?; // Focus the window so it can detect focus loss

            // Emit open event to search window
            let _ = window.emit("search-window-open", true);
        }
    }
```

Auto‚Äëhide search on blur and reposition/center helpers exist in the same file.

### Global shortcuts and tray

- Shortcut: `Shift+Alt+K` toggles the search window.
- Tray: Left‚Äëclick toggles search; menu offers ‚ÄúCheck for Updates‚Ä¶‚Äù.

```420:449:apps/desktop/src-tauri/src/lib.rs
                let search_shortcut =
                    Shortcut::new(Some(Modifiers::SHIFT | Modifiers::ALT), Code::KeyK);

                if let Ok(_) = app.handle().plugin(
                    tauri_plugin_global_shortcut::Builder::new()
                        .with_handler(move |app_handle, shortcut, event| {
                            if shortcut == &search_shortcut
                                && event.state() == ShortcutState::Pressed
                            {
                                println!("üîç Global shortcut triggered - checking search state via managed state");
                                // Get search state from managed state (same as commands use)
                                if let Some(managed_search_state) = app_handle.try_state::<SearchWindowState>() {
                                    let current_search_state = *managed_search_state.lock().unwrap();
                                    println!("üîç Shortcut: Search state from managed state: {}", current_search_state);

                                    // Use the same app_handle for both search state and toggle function
                                    let result = toggle_search_window(app_handle, &managed_search_state);
                                    match result {
                                        Ok(_) => println!("üîç Shortcut: toggle_search_window returned Ok"),
                                        Err(e) => println!("üîç Shortcut: toggle_search_window returned Err: {}", e)
                                    }
                                } else {
                                    println!("‚ùå Failed to get managed search state for shortcut");
                                }
                            }
                        })
                        .build(),
                ) {
                    let _ = app.global_shortcut().register(search_shortcut);
                }
```

### Deep links

- macOS deep link scheme: `midday://...` (see `tauri.conf.json`).
- Rust emits `deep-link-navigate` events with a cleaned path for the front end to handle.

```362:381:apps/desktop/src-tauri/src/lib.rs
fn handle_deep_link_event(app_handle: &tauri::AppHandle, urls: Vec<String>) {
    for url in &urls {
        if url.starts_with("midday://") {
            // Extract the path from the deep link
            let path = url.strip_prefix("midday://").unwrap_or("");

            // Remove any leading slashes
            let clean_path = path.trim_start_matches('/');

            // Get the main window and emit navigation event to frontend
            if let Some(window) = app_handle.get_webview_window("main") {
                // Emit event to frontend with just the path - frontend handles the full URL construction
                if let Ok(_) = window.emit("deep-link-navigate", clean_path) {
                    // Always show the window first, then bring it to front
                    let _ = window.show();
                    let _ = window.set_focus();
                }
            }
        }
    }
}
```

Front‚Äëend helpers for deep link handling and platform detection:

```10:23:packages/desktop-client/src/platform.ts
export async function listenForDeepLinks(handler: DeepLinkHandler) {
  if (!isDesktopApp()) {
    console.log("Deep links are only available in desktop app");
    return () => {}; // No-op cleanup for non-desktop environments
  }

  try {
    const unlisten = await listen<string>("deep-link-navigate", (event) => {
      console.log("üéØ Deep link navigation received:", event.payload);
      handler(event.payload);
    });

    console.log("‚úÖ Deep link listener registered");
    return unlisten;
  } catch (error) {
    console.error("Failed to listen for deep links:", error);
    return () => {};
  }
}
```

```43:46:packages/desktop-client/src/platform.ts
export function createDeepLink(path: string): string {
  const cleanPath = path.startsWith("/") ? path.slice(1) : path;
  return `midday://${cleanPath}`;
}
```

### Commands, events, and TS wrappers

- Define new native commands in Rust with `#[tauri::command]` and add them to the invoke handler list.
- Emit app‚Äëlevel events from Rust `Window`/`AppHandle` and consume them in the web app via `@tauri-apps/api/event`.
- Use the shared wrapper module for type‚Äësafe access in the front end.

```41:58:apps/desktop/src-tauri/src/lib.rs
#[tauri::command]
async fn check_for_updates(app: tauri::AppHandle) -> Result<(), String> {
    use tauri_plugin_dialog::{DialogExt, MessageDialogKind, MessageDialogButtons};
    use tauri_plugin_updater::UpdaterExt;

    #[cfg(desktop)]
    {
        // Try to check for updates
        if let Ok(updater) = app.updater() {
            match updater.check().await {
                Ok(Some(update)) => {
                    // Update available - show update dialog
                    let answer = app.dialog()
                        .message(format!("A new version {} is available. Would you like to update now?", update.version))
                        .title("Update Available")
                        .kind(MessageDialogKind::Info)
                        .buttons(MessageDialogButtons::OkCancel)
                        .blocking_show();
```

```1:6:packages/desktop-client/src/core.ts
export { invoke } from "@tauri-apps/api/core";
export { Window, getCurrentWindow } from "@tauri-apps/api/window";
export { openUrl } from "@tauri-apps/plugin-opener";
export { listen } from "@tauri-apps/api/event";
export { emit } from "@tauri-apps/api/event";
```

#### Event contract used today

- From Rust ‚Üí web app (`window.emit`):
  - `deep-link-navigate` (payload: `string` path)
  - `search-window-open` (payload: `boolean`)
- From web app ‚Üí Rust (`window.listen` in Rust via `Window::listen`):
  - `search-window-enabled` (payload: `boolean`)
  - `search-window-close-requested` (payload: none)

Rust side listeners for search events:

```511:541:apps/desktop/src-tauri/src/lib.rs
            // Listen for search window state events from the frontend
            let search_state_for_events = search_state.clone();
            let app_handle_for_events = app_handle.clone();
            window.listen("search-window-enabled", move |event| {
                if let Ok(enabled) = serde_json::from_str::<bool>(&event.payload()) {
                    println!("üîç Event received: search-window-enabled = {}", enabled);
                    *search_state_for_events.lock().unwrap() = enabled;
                    println!("üîç Search window state updated to {}", enabled);

                    // If search is disabled, clean up search window to prevent interference
                    if !enabled {
                        println!("üîç Search disabled, cleaning up search window");
                        if let Some(search_window) = app_handle_for_events.get_webview_window("search") {
                            let _ = search_window.close();
                            println!("üîç Search window closed and cleaned up");
                        }
                    }
                }
            });

            // Listen for search window close requests from the frontend
            let app_handle_for_close = app_handle.clone();
            window.listen("search-window-close-requested", move |_event| {
                println!("üîç Event received: search-window-close-requested");
                if let Some(search_window) = app_handle_for_close.get_webview_window("search") {
                    let _ = search_window.emit("search-window-open", false);
                    let _ = search_window.set_always_on_top(false);
                    let _ = search_window.hide();
                    println!("üîç Search window closed via close request");
                }
            });
```

### External links and security

- The shell opens external domains in the system browser and prevents navigation inside the webview.
- CSP is disabled in `tauri.conf.json` because we load trusted Midday origins only; keep plugin list explicit and minimal.

```32:46:apps/desktop/tauri.conf.json
  "plugins": {
    "deep-link": {
      "desktop": {
        "schemes": ["midday"]
      }
    },
    "updater": {
      "pubkey": "dW50cnVzdGVkIGNvbW1lbnQ6IG1pbmlzaWduIHB1YmxpYyBrZXk6IDkwNzNERjA3NzVBNDM3QkMKUldTOE42UjFCOTl6a0IrZW1EcEhhRHlUZ0Z2YW5sT0N4aVdQVE5aOEVTem9GTE1QRzJPM2JaUmMK",
      "endpoints": [
        "https://github.com/midday-ai/midday/releases/latest/download/latest.json"
      ],
      "createUpdaterArtifacts": true,
      "dangerousInsecureTransportProtocol": true
    }
  }
```

### Desktop‚Äëspecific styling (Tailwind variants)

- Use the Tailwind plugin to target desktop and platforms: `desktop:`, `mac:`, `windows:`, `linux:`.
- The plugin scopes selectors under `html.desktop` and `html.desktop-platform-*`. Ensure the app sets those root classes when running in Tauri.

```23:27:packages/desktop-client/src/desktop-variants.ts
  addVariant("desktop", ({ modifySelectors, separator }: VariantOptions) => {
    modifySelectors(({ className }: ModifySelectorsArgs) => {
      return `html.desktop .${e(`desktop${separator}${className}`)}`;
    });
  });
```

```31:48:packages/desktop-client/src/desktop-variants.ts
  const platformMap = {
    darwin: "mac",
    win32: "windows",
    linux: "linux",
  } as const;

  for (const platform of Object.keys(platformMap) as Array<
    keyof typeof platformMap
  >) {
    const variant = platformMap[platform];
    addVariant(variant, ({ modifySelectors, separator }: VariantOptions) => {
      modifySelectors(({ className }: ModifySelectorsArgs) => {
        return `html.desktop-platform-${platform} .${e(
          `${variant}${separator}${className}`,
        )}`;
      });
    });
  }
```

### Extension guide (add features safely)

- **Add a native command**
  1) In `apps/desktop/src-tauri/src/lib.rs`, write a function annotated with `#[tauri::command]`.
  2) Add it to `invoke_handler(tauri::generate_handler![...])` in `run()`.
  3) Export a thin TS wrapper in `packages/desktop-client` that calls `invoke("commandName", payload)`.
  4) Document the command name and payload shape here.

- **Emit/listen to events**
  - From Rust, call `window.emit("event", payload)`.
  - From TS, call `listen("event", cb)` (re‚Äëexported from `packages/desktop-client/src/core.ts`).

- **Create/manage windows**
  - Use unique labels (e.g., `"main"`, `"search"`). Start hidden (`visible(false)`), then show and focus when ready.
  - For ephemeral overlays (search), set `always_on_top(true)` while visible; auto‚Äëhide on blur.

- **Handle external navigation**
  - Keep `on_navigation` guard and `is_external_url` for browser handoff; never allow unknown origins inside the webview.

- **Updater UX**
  - Gate updates behind user confirmation. Use `tauri-plugin-updater` + `tauri-plugin-dialog` as in `check_for_updates`.

- **Quit behavior**
  - On `ExitRequested`, prevent exit and hide windows to keep global shortcuts active.

### Quick checklist

- [ ] Pick the right env (`MIDDAY_ENV`) and confirm the URL resolves.
- [ ] If adding a command, wire Rust `#[tauri::command]` + TS `invoke` wrapper.
- [ ] If adding UI affordances, consider desktop Tailwind variants and root HTML classes.
- [ ] For events, document payloads and add both emitter and listener.
- [ ] For new windows, use labels, start hidden, focus on show, and clean up on disable.
- [ ] Validate external link handling remains intact.
