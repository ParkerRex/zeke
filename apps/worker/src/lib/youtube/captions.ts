import { google, youtube_v3 } from 'googleapis';
import type { Readable } from 'node:stream';
import { log } from '../../log.js';

const DEFAULT_LANG_PREF = ['en-US', 'en', 'en-GB'];

export type CaptionSegment = {
  start: number;
  end: number;
  text: string;
};

export type CaptionDownloadResult = {
  trackId: string;
  languageCode: string;
  isAutoGenerated: boolean;
  name?: string;
  vtt: string;
  text: string;
  segments: CaptionSegment[];
};

function requireEnv(name: string): string {
  const value = process.env[name];
  if (!value) {
    throw new Error(`Missing required environment variable: ${name}`);
  }
  return value;
}

function createYouTubeOAuthClient() {
  const clientId = requireEnv('YOUTUBE_OAUTH_CLIENT_ID');
  const clientSecret = requireEnv('YOUTUBE_OAUTH_CLIENT_SECRET');
  const refreshToken = requireEnv('YOUTUBE_OAUTH_REFRESH_TOKEN');

  const oauth2Client = new google.auth.OAuth2({
    clientId,
    clientSecret,
  });

  oauth2Client.setCredentials({
    refresh_token: refreshToken,
  });

  return google.youtube({ version: 'v3', auth: oauth2Client });
}

function pickBestTrack(
  items: youtube_v3.Schema$Caption[] | undefined,
  preferredLanguages: string[]
): youtube_v3.Schema$Caption | null {
  if (!items?.length) {
    return null;
  }

  const normalize = (code?: string | null) => code?.toLowerCase() ?? '';
  const preferredSet = new Set(preferredLanguages.map((lang) => lang.toLowerCase()));

  const sorted = [...items].sort((a, b) => {
    const aLang = normalize(a.snippet?.language);
    const bLang = normalize(b.snippet?.language);
    const aPreferred = preferredSet.has(aLang) ? 1 : 0;
    const bPreferred = preferredSet.has(bLang) ? 1 : 0;
    if (aPreferred !== bPreferred) {
      return bPreferred - aPreferred;
    }
    const aManual = a.snippet?.trackKind !== 'ASR' ? 1 : 0;
    const bManual = b.snippet?.trackKind !== 'ASR' ? 1 : 0;
    if (aManual !== bManual) {
      return bManual - aManual;
    }
    return 0;
  });

  return sorted[0] ?? null;
}

function parseTimestamp(value: string): number {
  const timeParts = value.trim().split(':');
  const last = timeParts.pop() || '0';
  const [secs, millis = '0'] = last.split(/[.,]/);
  let seconds = Number.parseInt(secs, 10) + Number(`0.${millis}`);

  if (timeParts.length) {
    const minutes = Number.parseInt(timeParts.pop() ?? '0', 10);
    seconds += minutes * 60;
  }
  if (timeParts.length) {
    const hours = Number.parseInt(timeParts.pop() ?? '0', 10);
    seconds += hours * 3600;
  }
  return Number.isFinite(seconds) ? seconds : 0;
}

function parseVtt(vtt: string): CaptionSegment[] {
  const segments: CaptionSegment[] = [];
  const blocks = vtt.split(/\r?\n\r?\n/);
  for (const block of blocks) {
    const lines = block.split(/\r?\n/).filter(Boolean);
    if (!lines.length) {
      continue;
    }
    const timingLine = lines.find((line) => line.includes('-->'));
    if (!timingLine) {
      continue;
    }
    const [startRaw, endRaw] = timingLine.split('-->').map((part) => part.trim());
    if (!startRaw || !endRaw) {
      continue;
    }
    const textLines = lines
      .slice(lines.indexOf(timingLine) + 1)
      .map((ln) => ln.replace(/<[^>]+>/g, '').trim())
      .filter(Boolean);
    if (!textLines.length) {
      continue;
    }
    segments.push({
      start: parseTimestamp(startRaw),
      end: parseTimestamp(endRaw),
      text: textLines.join(' '),
    });
  }
  return segments;
}

async function toBuffer(data: unknown): Promise<Buffer> {
  if (!data) {
    return Buffer.alloc(0);
  }
  if (Buffer.isBuffer(data)) {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return Buffer.from(data);
  }
  if (typeof data === 'string') {
    return Buffer.from(data, 'utf-8');
  }
  if ((data as Readable).pipe) {
    const stream = data as Readable;
    const chunks: Buffer[] = [];
    for await (const chunk of stream) {
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
    }
    return Buffer.concat(chunks);
  }
  throw new Error('unsupported_caption_payload');
}

export async function downloadVideoCaptions(
  videoId: string,
  preferredLanguages: string[] = DEFAULT_LANG_PREF
): Promise<CaptionDownloadResult> {
  const youtube = createYouTubeOAuthClient();

  log('youtube_captions_list_start', { videoId });
  const { data } = await youtube.captions.list({
    part: ['snippet'],
    videoId,
  });

  const track = pickBestTrack(data.items, preferredLanguages);
  if (!track?.id) {
    throw new Error('no_caption_track_found');
  }

  log('youtube_captions_list_success', {
    videoId,
    caption_id: track.id,
    language: track.snippet?.language,
    track_kind: track.snippet?.trackKind,
  });

  const response = await youtube.captions.download(
    { id: track.id, tfmt: 'vtt' },
    { responseType: 'arraybuffer' }
  );

  const buffer = await toBuffer(response.data);
  const vtt = buffer.toString('utf-8');
  const segments = parseVtt(vtt);
  const text = segments.map((segment) => segment.text).join(' ').trim();

  if (!text) {
    throw new Error('empty_caption_text');
  }

  return {
    trackId: track.id,
    languageCode: track.snippet?.language ?? 'unknown',
    isAutoGenerated: track.snippet?.trackKind === 'ASR',
    name: track.snippet?.name ?? undefined,
    vtt,
    text,
    segments,
  };
}
