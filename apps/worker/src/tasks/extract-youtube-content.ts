import type PgBoss from "pg-boss";
import {
  findDiscoveriesByIds,
  findStoryIdByContentHash,
  insertContents,
  insertStory,
} from "../db.js";
import {
  downloadVideoCaptions,
  type CaptionDownloadResult,
} from "../lib/youtube/captions.js";
import { log } from "../log.js";
import { prepareYouTubeTranscript } from "../storage/prepare-youtube-transcript.js";
import { hashText } from "../util.js";

const DESCRIPTION_MAX_LENGTH = 500;
const MAX_PREVIEW_SEGMENTS = 10;
const TIME_PAD_LENGTH = 2;
const SECONDS_PER_HOUR = 3600;
const SECONDS_PER_MINUTE = 60;

export type YouTubeExtractionJobData = {
  rawItemIds: string[];
  videoId: string;
  sourceKind: string;
};

type DiscoveryRow = {
  id: string;
  url: string;
  title: string | null;
  kind?: string | null;
  metadata: Record<string, unknown> | null;
};

type NormalizedVideoMetadata = {
  title?: string;
  channelTitle?: string;
  durationSeconds?: number;
  publishedAt?: string;
  viewCount?: number;
  likeCount?: number;
  description?: string;
};

export async function extractYouTubeContent(
  jobData: YouTubeExtractionJobData,
  boss: PgBoss,
) {
  const { rawItemIds = [], videoId, sourceKind } = jobData;
  const rows = await findDiscoveriesByIds(rawItemIds);

  for (const row of rows) {
    await processYouTubeRow(row, videoId, sourceKind, boss);
  }
}

async function processYouTubeRow(
  row: DiscoveryRow,
  videoId: string,
  sourceKind: string,
  boss: PgBoss,
): Promise<void> {
  const t0 = Date.now();
  const videoUrl = row.url;
  const videoMetadata = normalizeMetadata(row.metadata);

  try {
    log("youtube_extract_start", {
      comp: "extract",
      raw_item_id: row.id,
      video_id: videoId,
      source_kind: sourceKind,
      url: videoUrl,
    });

    const captions = await downloadVideoCaptions(videoId);

    log("youtube_captions_downloaded", {
      comp: "extract",
      raw_item_id: row.id,
      video_id: videoId,
      language: captions.languageCode,
      auto_generated: captions.isAutoGenerated,
      segment_count: captions.segments.length,
    });

    const transcriptData = await prepareYouTubeTranscript(
      videoId,
      captions.vtt,
      captions.text,
    );
    if (!transcriptData.success) {
      throw new Error(`Transcript preparation failed: ${transcriptData.error}`);
    }

    const enhancedText = formatYouTubeContent(
      captions.text,
      videoMetadata,
      captions,
    );

    const content_hash = hashText(enhancedText);
    const content_id = await insertContents({
      raw_item_id: row.id,
      text: enhancedText,
      html_url: videoUrl,
      lang: captions.languageCode,
      content_hash,
      transcript_url: transcriptData.transcriptUrl,
      transcript_vtt: transcriptData.vttContent,
      duration_seconds: videoMetadata.durationSeconds ?? null,
      view_count: videoMetadata.viewCount ?? null,
    });

    const existingStoryId = await findStoryIdByContentHash(content_hash);
    const storyId =
      existingStoryId ??
      (await insertStory({
        content_id,
        title: videoMetadata.title || row.title || null,
        canonical_url: videoUrl,
        primary_url: videoUrl,
        kind: "youtube",
        published_at: videoMetadata.publishedAt ?? null,
      }));

    await boss.send("analyze:llm", { storyId });

    log("youtube_extract_success", {
      comp: "extract",
      raw_item_id: row.id,
      content_id,
      story_id: storyId,
      video_id: videoId,
      content_hash,
      url: videoUrl,
      text_len: enhancedText.length,
      duration_seconds: videoMetadata.durationSeconds ?? null,
      language: captions.languageCode,
      duration_ms: Date.now() - t0,
    });
  } catch (err) {
    log(
      "youtube_extract_error",
      {
        comp: "extract",
        raw_item_id: row.id,
        video_id: videoId,
        url: videoUrl,
        err: String(err),
      },
      "error",
    );
  }
}

function normalizeMetadata(
  metadata: Record<string, unknown> | null | undefined,
): NormalizedVideoMetadata {
  if (!metadata) {
    return {};
  }

  const asRecord = metadata as Record<string, unknown>;
  return {
    title: typeof asRecord.title === "string" ? asRecord.title : undefined,
    channelTitle:
      typeof asRecord.channelTitle === "string"
        ? asRecord.channelTitle
        : undefined,
    durationSeconds: parseIsoDuration(
      typeof asRecord.duration === "string" ? asRecord.duration : undefined,
    ),
    publishedAt:
      typeof asRecord.publishedAt === "string"
        ? asRecord.publishedAt
        : undefined,
    viewCount: coerceNumber(asRecord.viewCount),
    likeCount: coerceNumber(asRecord.likeCount),
    description:
      typeof asRecord.description === "string"
        ? asRecord.description
        : undefined,
  };
}

function coerceNumber(value: unknown): number | undefined {
  if (typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  if (typeof value === "string") {
    const parsed = Number.parseInt(value, 10);
    if (Number.isFinite(parsed)) {
      return parsed;
    }
  }
  return undefined;
}

function parseIsoDuration(duration?: string): number | undefined {
  if (!duration) {
    return undefined;
  }
  const match = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/.exec(duration);
  if (!match) {
    return undefined;
  }
  const hours = match[1] ? Number.parseInt(match[1], 10) : 0;
  const minutes = match[2] ? Number.parseInt(match[2], 10) : 0;
  const seconds = match[3] ? Number.parseInt(match[3], 10) : 0;
  return hours * SECONDS_PER_HOUR + minutes * SECONDS_PER_MINUTE + seconds;
}

function formatYouTubeContent(
  transcriptText: string,
  metadata: NormalizedVideoMetadata,
  captions: CaptionDownloadResult,
): string {
  const sections: string[] = [];

  sections.push("=== VIDEO INFORMATION ===");
  sections.push(`Title: ${metadata.title ?? "Unknown"}`);
  sections.push(`Channel: ${metadata.channelTitle ?? "Unknown"}`);
  sections.push(
    `Duration: ${formatDuration(metadata.durationSeconds ?? undefined)}`,
  );
  sections.push(
    `Published At: ${metadata.publishedAt ? new Date(metadata.publishedAt).toISOString() : "Unknown"}`,
  );
  if (typeof metadata.viewCount === "number") {
    sections.push(`Views: ${metadata.viewCount.toLocaleString()}`);
  }
  if (typeof metadata.likeCount === "number") {
    sections.push(`Likes: ${metadata.likeCount.toLocaleString()}`);
  }
  if (metadata.description) {
    const snippet = metadata.description.substring(0, DESCRIPTION_MAX_LENGTH);
    sections.push(
      `Description: ${snippet}${
        metadata.description.length > DESCRIPTION_MAX_LENGTH ? "..." : ""
      }`,
    );
  }

  sections.push("");
  sections.push("=== CAPTION INFORMATION ===");
  sections.push(`Language: ${captions.languageCode}`);
  sections.push(`Auto Generated: ${captions.isAutoGenerated}`);
  sections.push(`Segments: ${captions.segments.length}`);

  sections.push("");
  sections.push("=== TRANSCRIPT ===");
  sections.push(transcriptText);

  if (captions.segments.length > 0) {
    sections.push("");
    sections.push("=== TIMESTAMPED SEGMENTS ===");
    const maxSegments = Math.min(
      MAX_PREVIEW_SEGMENTS,
      captions.segments.length,
    );
    for (let i = 0; i < maxSegments; i++) {
      const segment = captions.segments[i];
      sections.push(
        `[${formatTimestamp(segment.start)} - ${formatTimestamp(segment.end)}] ${segment.text}`,
      );
    }
    if (captions.segments.length > maxSegments) {
      sections.push(
        `... and ${captions.segments.length - maxSegments} more segments`,
      );
    }
  }

  return sections.join("\n");
}

function formatDuration(seconds?: number): string {
  if (!seconds || seconds <= 0) {
    return "0:00";
  }
  const hours = Math.floor(seconds / SECONDS_PER_HOUR);
  const minutes = Math.floor((seconds % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE);
  const secs = Math.floor(seconds % SECONDS_PER_MINUTE);
  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(TIME_PAD_LENGTH, "0")}:${secs
      .toString()
      .padStart(TIME_PAD_LENGTH, "0")}`;
  }
  return `${minutes}:${secs.toString().padStart(TIME_PAD_LENGTH, "0")}`;
}

function formatTimestamp(seconds?: number): string {
  const safeSeconds = Number.isFinite(seconds) ? Number(seconds) : 0;
  const minutes = Math.floor(safeSeconds / SECONDS_PER_MINUTE);
  const secs = Math.floor(safeSeconds % SECONDS_PER_MINUTE);
  return `${minutes}:${secs.toString().padStart(TIME_PAD_LENGTH, "0")}`;
}
